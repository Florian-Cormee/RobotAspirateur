@startuml "Diagramme de classe"

skinparam linetype ortho
'skinparam classAttributeIconSize 0

' package "geometrie" {
    abstract class Forme {
        # centre : Point2D

        + Forme(p : Position)
        + Forme(x : double , y : double)

        + getCentre() : Position
        + setCentre(p : Position) : void
        + estSuperposee(f : Forme) : boolean
        {abstract} + rotation(alpha : double) : Forme
        {abstract} + rotation(alpha : double , p : Position) : Forme
    }
    Forme "1" *-- "1" Point2D

    class Rectangle {
        # longueur : double
        # largeur : double

        + Rectangle()
        + Rectangle(p : Position , l1 : double , l2 : double)
        + Rectangle(x : double , y : double , l1 : double , l2 : double)

        + getLongueur() : double
        + setLongueur(l : double) : void
        + getLargeur() : double
        + setLargeur(l : double) : void
        + rotation(alpha : double) : Forme
        + rotation(alpha : double , p : Position) : Forme
    }
    Rectangle --|> Forme

    class Cercle {
        # diametre : double

        + Cercle()
        + Cercle(p : Position , d : double)
        + Cercle(x : double , y : double , d : double)

        + getDiametre() : double
        + setDiametre(d : double) : void
        + rotation(alpha : double) : Forme
        + rotation(alpha : double , p : Position) : Forme
    }
    Cercle --|> Forme

    class ArcDeCercle {
        # ang1 : double
        # ang2 : double

        + ArcDeCercle(p : Psoition , d : double , a1 : double , a2 : double)
        + ArcDeCercle(x : double , y : double , d : double , a1 : double , a2 : double)

        + getOuverture() : double
        + getorientation() : double
        + setOuverture(o : double) : void
        + setOrientation(o : double) : void
        + rotation(alpha : double) : Forme
        + rotation(alpha : double , p : Position) : Forme
    }
    ArcDeCercle --|> Cercle

    class Polygone {
        # points : List<Position>

        + Polygone(p : Position , cp : Collection<Position>)

        + getPoints() : List<Position>
    }
    Polygone --|> Forme

    class Vecteur2D {
        # x : double
        # y : double

        + Vecteur2D()
        + Vecteur2D(x : double , y : double)

        + getX() : double
        + getY() : double
        + addition(v : Vecteur2D) : Vecteur2D
        + getAngle(v : Vecteur2D) : double
        + norme() : double
        + normalise() : Vecteur2D
        + produit(a : double) : Vecteur2D
        + rotation(angle : double) : Vecteur2D
        + scalaire(v : Vecteur2D) : double
        + soustraction(v : Vecteur2D) : Vecteur2D
        + clone() : Vecteur2D
        + toString() : String
        + equals(o : Object) : boolean
        + equals(v : Vecteur2D , double epsilon) : boolean
    }

    class Point2D {
        # origine : Point2D
        # position : Vecteur2D

        + Point2D(position : Vecteur2D)
        + Point2D(position : Vecteur2D, origine : Point2D)

        + getOrigine() : Point2D
        + getPositionRelative() : Vecteur2D
        + getPositionRelative(p : Point2D) : Vecteur2D
        + deplace(v : Vecteur2D) : Point2D
        + toString() : String
        + equals(o : Object) : boolean
        + equals(p : Point2D , double epsilon) : boolean
    }
    Point2D "1" *-- "1" Vecteur2D
    ' Point2D "0..1" *-- "0..1" Point2D
' }

' package "element" {
    class BasiqueElementFactory{
        + capteurContact(forme: Forme): IModule<Boolean>
        + capteurSalete(forme: Forme): IModule<Boolean>
        + obstacle(forme: Forme): ICollisionable
        + robot(forme: Forme, strategie: IStrategie, orientation: double, ecartRoues: double, modules: IModule<?>...): IRobot
        + tache(forme: Forme)
    }
    BasiqueElementFactory -|> ElementFactory

    abstract class Element {
        # forme: Forme
        + Element(f: Forme)
        + rotation(angle: double, centre: Point2D): void
        + translation(deplacement: Vecteur2D): void
    }
    Element ..|> IElement
    Element "1" *-- "1" Forme

    interface IActuallisable {
        {abstract} + actualise(simulation : Simulation): void
        {abstract} + actualise(simulation : Simulation, appeleur: Object): void
    }
    IActuallisable ..|> IElement

    interface ICollisionable {
        {abstract}+ collisionne(element: ICollisionable): boolean
        {abstract}+ gereCollision(element: ICollisionable): void
    }
    ICollisionable ..|> IElement

    interface IDeplacable {
        {abstract}+ rotation(angle: double, centre: Point2D): void
        {abstract}+ translation(Vecteur2D deplacement): void
    }
    IDeplacable ..|> IElement

    interface IElement {
        {abstract} + getForme() : Forme
    }

    interface INettoyable
    INettoyable ..|> IElement

    interface IRobot {
        {abstract}+ deplace(dG: double, dD: double): void
        {abstract}+ getModules(): List<IModule<?>>
        {abstract}+ <T extends IModule<?>> getModules(c: Class<? extends T>): List<T>
        {abstract}+ getStrategie(): IStrategie
        {abstract}+ isNettoie(): boolean
        {abstract}+ setNettoie(etat: boolean): void
        {abstract}+ getPosition(): Point2D
        {abstract}+ getOrientation(): double
    }
    IRobot ..|> ICollisionable
    IRobot ..|> IActuallisable

    class Obstacle {
        + Obstacle(forme: Forme)
        + gereCollision(element: ICollisionable) : boolean
    }
    Obstacle --|> Element
    Obstacle ..|> ICollisionable

    class Robot {
        # modules: List<IModule<?>>
        # strategie: IStrategie
        # theta: double
        # ecartRoues: double
        # nettoie: boolean
        # dernierePos: Point2D
        # derniereTheta: double
        + Robot(forme: Forme, modules: Collection<? extends IModule<?>>, strategie: IIStrategie, theta: double, ecartRoues: double)
        + actualise(simulation: Simulation): void
        + deplace(dG: double, dD: double): void
        + gereCollision(element: ICollisionable): void
        + getModules():  List<IModule<?>>
        + <T extends IModule<?>> getModules(c : Class<? extends T>) : List<T>
        + isNettoie(): boolean
        + rotation(angle: double, centre: Point2D): void
        + setNettoie(etat: boolean): void
        + translation(deplacement: Vecteur2D): void
    }
    Robot --|> Element
    Robot ..|> IRobot
    Robot  "1" *-- "0..n" IModule
    Robot  "1" *-- "1" IStrategie
    Robot "1" *-- "1" Point2D

    class Tache {
        + Tache(fomre: Forme)
    }
    Tache --|> Element
    Tache ..|> INettoyable
' }

' package "element.module" {
    interface IModule<T> {
        {abstract} + getInfo() : T
    }
    IModule ..|> IElement

    class CapteurContact<Boolean> {
        + CapteurContact(f : ArcDeCercle)

        + getInfo() : Boolean
        + actualise(simulation : Simulation) : boolean
    }
    CapteurContact --|> Element
    CapteurContact ..|> IModule

    class CapteurSalete<Boolean> {
        + CapteurSalete(f : Cercle)

        + getInfo() : Boolean
        + actualise(simulation : Simulation) : boolean
    }
    CapteurSalete --|> Element
    CapteurSalete ..|> IModule

    class CapteurLaser<Double> {
        # portee : Forme

        + CapteurLaser(f : Forme , p : Rectangle)

        + getInfo() : boolean

        + actualise(simulation : Simulation) : boolean
    }
    CapteurLaser --|> Element
    CapteurLaser ..|> IModule
' }

' package "exception" {
    class NoIntersectionException {
        - forme: Forme
        + NoIntersectionException(f: Forme)
        + NoIntersectionException(f: Forme, msg: String)
        + NoIntersectionException(message: String, cause: Throwable, forme: Forme)
    }
    NoIntersectionException -|> Exception

    class NonRelatifException {
        - forme: Forme
        + NonRelatifException(f: Forme)
        + NonRelatifException(f: Forme, msg: String)
    }
    NonRelatifException -|> Exception
' }

' package "strategie" {
    interface IStrategie {
        {abstract} + decide(robot: IRobot): void
    }

    class StrategieAleatoire {
        - angleCible: double
        - distArr: double
        - kRot: double
        - etat: Etat
        + StrategieAleatoire()
        + decide(robot: IRobot): void
    }
    StrategieAleatoire ..|> IStrategie

    class StrategieChemin {
        + StrategieChemin()
        + decide(robot: IRobot): void
    }
    StrategieChemin ..|> IStrategie

    class StrategieSuiveurMurs{
        + StrategieSuiveurMurs()
        + decide(robot: IRobot): void
    }
    StrategieSuiveurMurs ..|> IStrategie
'}

'package "vue" {
    'package "element" {
        ' package "module" {
            class CapteurContactDessinable {
                - changementCouleur: LocalTime
                - derniereCouleur: Color
                + CapteurContactDessinable(forme: Forme)
                + dessine(graphics2D: Graphics2D, echelle: double): void
            }
            CapteurContactDessinable -|> CapteurContact
            CapteurContactDessinable ..|> IDessinable

            class CapteurDessinable<T> {
                - capteur: IModule<T>
                - plein: boolean
                + CapteurDessinable(capteur: IModule<T>, plein: boolean)
                + actualise(simulation: Simulation, appeleur: Object)
                + dessine(graphics2d: Graphics2D, echelle: double)
                + getForme(): Forme
                + getInfo(): T
                + rotation(angle: double, centre: Point2D): void
                + translation(deplacement: Vecteur2D): void
            }
            CapteurDessinable ..|> IModule
            CapteurDessinable ..|> IDessinable

            class CapteurSaleteDessinable {
                - changementCouleur: LocalTime
                - derniereCouleur: Color
                + CapteurSaleteDessinable(forme: Forme)
                + dessine(graphics2D: Graphics2D, echelle: double): void
            }
            CapteurSaleteDessinable -|> CapteurSalete
            CapteurSaleteDessinable ..|> IDessinable
        ' }

        class ObstacleDessinable {
            - couleur: Color
            + ObstacleDessinable(forme: Forme, couleur: Color)
            + dessine(graphics2D: Graphics2D, echelle: double): void
        }
        ObstacleDessinable -|> Obstacle
        ObstacleDessinable ..|> IDessinable

        class RobotDessinable {
            + RobotDessinable(forme: Forme, couleur: Color)
            + dessine(graphics2D: Graphics2D, echelle: double): void
            + dessineDirection(graphics2D: Graphics2D, echelle: double): void
        }
        RobotDessinable -|> Robot
        RobotDessinable ..|> IDessinable

        class TacheDessinable {
            - couleur: Color
            + TacheDessinable(forme: Forme, couleur: Color)
            + dessine(graphics2D: Graphics2D, echelle: double): void
        }
        TacheDessinable -|> Tache
        TacheDessinable ..|> IDessinable
    '}
    'package "forme" {
        class ArcDeCercleDessinateur {
            + ArcDeCercleDessinateur()
            + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: ArcDeCercle): void
        }
        ArcDeCercleDessinateur ..|> IDessinateur

        class CercleDessinateur {
            + CercleDessinateur()
            + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: Cercle): void
        }
        CercleDessinateur ..|> IDessinateur

        class FormeDessinateur {
            + FormeDessinateur()
            + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: Forme): void
        }
        FormeDessinateur ..|> IDessinateur

        class GeometrieDessinateurFactory {
            +{static} instance: GeometrieDessinateurFactory
            - GeometrieDessinateurFactory()
            + arcDeCercle(): IDessinateur<ArcDeCercle>
            + cercle(): IDessinateur<Cercle>
            + forme(): IDessinateur<Forme>
            + polygone(): IDessinateur<Polygone>
            + rectangle(): IDessinateur<Rectangle>
            + segment(): IDessinateur<Segment>
        }

        class PolygonDessinateur {
            + PolygonDessinateur()
            + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: Polygone): void
        }
        PolygonDessinateur ..|> IDessinateur

        class RectangleDessinateur {
            + RectangleDessinateur()
            + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: Rectangle): void
        }
        RectangleDessinateur ..|> IDessinateur

        class SegmentDessinateur {
            + SegmentDessinateur()
            + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: Segment): void
            - versPositionEnPixels(p: Point2D, echelle: double): int[]
        }
        SegmentDessinateur ..|> IDessinateur
    '}

    class ElementDessinableFactory {
        + capteurContact(forme: Forme): IModule<Boolean>
        + capteurSalete(forme: Forme): IModule<Boolean>
        + obstacle(forme: Forme): ICollisionable
        + robot(forme: Forme, strategie: IStrategie, orientation: double, ecartRoues: double, modules: IModule<?>...): IRobot
        + tache(forme: Forme)
    }
    ElementDessinableFactory -|> ElementFactory

    interface IDessinable {
        +{abstract} dessine(graphics2D: Graphics2D, echelle: double): void
    }

    interface IDessinateur<T> {
        + dessine(graphics2D: Graphics2D, echelle: double, rempli: boolean, element: T): void
    }

    class SimulationPanel {
        - simulation: Simulation
+ SimulationPanel(simulation: Simulation)
- dessineElement(e: IElement, graphics2D: Graphics2D, echelle: double): void
- echelle(): double
+ notifie(source: IObservable<Simulation>): void
+ void paint(g: Graphics)
    }
    SimulationPanel -|> JPanel
    SimulationPanel ..|> IObservateur

'}

abstract ElementFactory {
    {static}+ getInstance(): ElementFactory
    {abstract}+ capteurContact(forme: Forme): IModule<Boolean>
    {abstract}+ capteurSalete(forme: Forme): IModule<Boolean>
    {abstract}+ obstacle(forme: Forme): ICollisionable
    {abstract}+ robot(forme: Forme, strategie: IStrategie, orientation: double, ecartRoues: double, modules: IModule<?>...): IRobot
    {abstract}+ tache(forme: Forme)
}

interface IObservable<T> {
    {abstract}+ ajouteObservateur(obs: IObservateur<T>): void
    {abstract}+ estObserve(obs: IObservateur<T>): boolean
    {abstract}+ retireObservateur(obs: IObservateur<T>): void
    {abstract}+ notifierTous(): void
}

interface IObservateur<T> {
    {abstract}+ notifie(source: IObservable<T>): void
}

class Simulation {
    {static}+ T: double
    - observateurs: List<IObservateur<Simulation>>
    # elements: ArrayList<Element>
    # bordures: ICollisionable

    + Simulation(bordures: ICollisionable, elements: Collection<? extends IElement>)
    - actualise(): void
    + ajouteObservateur(obs: IObservateur<Simulation>): void
    + estObserve(obs: IObservateur<Simulation>): boolean
    + getBordures(): ICollisionable
    + getElements(): List<IElement>
    + <T extends IElement>getElements(c : Class<? extends T>) : List<T>
    + lnacer(): void
    + notifierTous(): void
    + retireObservateur(obs: IObservateur<Simulation>): void
}
Simulation ..|> IObservable
Simulation "0..1" *-- "0..n" IElement

class SimulationStdBuilder {
    - elements: List<IElement>
    - factory: ElementFactory
    - bordures: ICollisionable
    + SimulationStdBuilder(factory: ElementFactory)
    + ajouteElement(element: IElement): void
    + ajouteObstacleCirculaire(x: double, y: double, diametre: double): void
    + ajouteRobotStandard(x: double, y: double, orientation: double, strategie: IStrategie): void
    + ajouteTacheCirculaire(x: double, y: double, diametre: double): void
    + build(): Simulation
}
@enduml
