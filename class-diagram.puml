@startuml "Diagramme de classe"

skinparam linetype ortho

' package "geometrie" {
    abstract class Forme {
        # centre : Point2D

        + Forme(p : Position)
        + Forme(x : double , y : double)

        + getCentre() : Position
        + setCentre(p : Position) : void
        + estSuperposee(f : Forme) : boolean
        {abstract} + rotation(alpha : double) : Forme
        {abstract} + rotation(alpha : double , p : Position) : Forme
    }
    Forme "1" *-- "1" Point2D

    class Rectangle {
        # longueur : double
        # largeur : double

        + Rectangle()
        + Rectangle(p : Position , l1 : double , l2 : double)
        + Rectangle(x : double , y : double , l1 : double , l2 : double)

        + getLongueur() : double
        + setLongueur(l : double) : void
        + getLargeur() : double
        + setLargeur(l : double) : void
        + rotation(alpha : double) : Forme
        + rotation(alpha : double , p : Position) : Forme
    }
    Rectangle --|> Forme

    class Cercle {
        # diametre : double

        + Cercle()
        + Cercle(p : Position , d : double)
        + Cercle(x : double , y : double , d : double)

        + getDiametre() : double
        + setDiametre(d : double) : void
        + rotation(alpha : double) : Forme
        + rotation(alpha : double , p : Position) : Forme
    }
    Cercle --|> Forme

    class ArcDeCercle {
        # ang1 : double
        # ang2 : double

        + ArcDeCercle(p : Psoition , d : double , a1 : double , a2 : double)
        + ArcDeCercle(x : double , y : double , d : double , a1 : double , a2 : double)

        + getOuverture() : double
        + getorientation() : double
        + setOuverture(o : double) : void
        + setOrientation(o : double) : void
        + rotation(alpha : double) : Forme
        + rotation(alpha : double , p : Position) : Forme
    }
    ArcDeCercle --|> Cercle

    class Polygone {
        # points : List<Position>

        + Polygone(p : Position , cp : Collection<Position>)

        + getPoints() : List<Position>
    }
    Polygone --|> Forme

    class Vecteur2D {
        # x : double
        # y : double

        + Vecteur2D()
        + Vecteur2D(x : double , y : double)

        + getX() : double
        + getY() : double
        + addition(v : Vecteur2D) : Vecteur2D
        + getAngle(v : Vecteur2D) : double
        + norme() : double
        + normalise() : Vecteur2D
        + produit(a : double) : Vecteur2D
        + rotation(angle : double) : Vecteur2D
        + scalaire(v : Vecteur2D) : double
        + soustraction(v : Vecteur2D) : Vecteur2D
        + clone() : Vecteur2D
        + toString() : String
        + equals(o : Object) : boolean
        + equals(v : Vecteur2D , double epsilon) : boolean
    }

    class Point2D {
        # origine : Point2D
        # position : Vecteur2D

        + Point2D(position : Vecteur2D)
        + Point2D(position : Vecteur2D, origine : Point2D)

        + getOrigine() : Point2D
        + getPositionRelative() : Vecteur2D
        + getPositionRelative(p : Point2D) : Vecteur2D
        + deplace(v : Vecteur2D) : Point2D
        + toString() : String
        + equals(o : Object) : boolean
        + equals(p : Point2D , double epsilon) : boolean
    }
    Point2D "1" *-- "1" Vecteur2D
    ' Point2D "0..1" *-- "0..1" Point2D
' }

' package "element" {
    interface IElement {
        {abstract} + getForme() : Forme
    }
    IElement ..|> IActuallisable

    interface ICollisionable {
        {abstract} + gereCollision(element : IElement) : boolean
    }
    ICollisionable ..|> IElement

    interface INettoyable
    INettoyable ..|> IElement

    abstract class Element {
        #forme : Forme

        + Element(f : Forme)

        + getForme() : Forme
    }
    Element ..|> IElement
    Element "1" *-- "1" Forme

    class Obstacle {
        + Obstacle(f : Forme)

        + gereCollision(element : IElement) : boolean
        + actualise(simulation : Simulation) : boolean
    }
    Obstacle --|> Element
    Obstacle ..|> ICollisionable

    class Robot {
        # direction : Vecteur2D
        # vitesse : double
        # modules : List<IModule<?>>
        # IStrategie : IStrategie

        + Robot(forme : Forme, modules : Collection<? extends IModule<?>>, IStrategie : IIStrategie, vitesse double)

        + getPosition() : Position
        + deplace(dl : double , dr : double , ecartRoues : double) : Position
        + getVitesse() : double
        + setVitesse(v : double) : void
        + getIStrategie() : IStrategie
        + getModules() :  List<IModule<?>>
        + <T extends IModule<?>> getModules(c : Class<T>) :  List<T>
        + actualise(simulation : Simulation) : boolean
        + gereCollision(element : IElement) : boolean
    }
    Robot --|> Element
    Robot ..|> ICollisionable
    Robot  "1" *-- "0..n" IModule
    Robot  "1" *-- "1" IStrategie
    Robot "1" *-- "1" Vecteur2D

    class Tache {
        + Tache(f : Forme)

        + actualise(simulation : Simulation) : boolean
    }
    Tache --|> Element
    Tache ..|> INettoyable
' }

' package "element.module" {
    interface IModule<T> {
        {abstract} + getInfo() : T
    }
    IModule ..|> IElement

    class CapteurContact<Boolean> {
        + CapteurContact(f : ArcDeCercle)

        + getInfo() : Boolean
        + actualise(simulation : Simulation) : boolean
    }
    CapteurContact --|> Element
    CapteurContact ..|> IModule

    class CapteurSalete<Boolean> {
        + CapteurSalete(f : Cercle)

        + getInfo() : Boolean
        + actualise(simulation : Simulation) : boolean
    }
    CapteurSalete --|> Element
    CapteurSalete ..|> IModule

    class CapteurLaser<Double> {
        # portee : Forme

        + CapteurLaser(f : Forme , p : Rectangle)

        + getInfo() : boolean

        + actualise(simulation : Simulation) : boolean
    }
    CapteurLaser --|> Element
    CapteurLaser ..|> IModule
' }

' package "strategie" {
    interface IStrategie {
        {abstract} + update(r : Robot) : boolean
    }

    class StrategieAleatoire
    StrategieAleatoire ..|> IStrategie

    class StrategieChemin
    StrategieChemin ..|> IStrategie

    class StrategieSuiveurMurs
    StrategieSuiveurMurs ..|> IStrategie
' }

interface IActuallisable {
    {abstract} + actualise(simulation : Simulation) : boolean
}

class Simulation {
    # elems : ArrayList<Element>

    + getCollisionable() : List<Collisionable>
    + getElems(c : Class<T>) : List<T>
    + play() : void
    + pause() : void
    + quit() : void
    # update() : void
    # run() : void
}
Simulation ..|> Runnable
Simulation "0..1" *-- "0..n" IElement

interface Runnable
@enduml
